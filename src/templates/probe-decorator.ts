/**
 * Angular Runtime X-Ray Performance Decorators
 * Auto-generated by Angular Runtime X-Ray Extension
 */

export interface PerformanceData {
    className: string;
    methodName: string;
    executionTime: number;
    timestamp: number;
    args?: any[];
    result?: any;
}

export interface WebSocketClient {
    send(data: any): void;
    connect(): void;
    disconnect(): void;
}

// WebSocket client for communicating with VS Code extension
class XRayWebSocketClient implements WebSocketClient {
    private ws: WebSocket | null = null;
    private reconnectAttempts = 0;
    private maxReconnectAttempts = 5;
    private reconnectDelay = 1000;

    constructor(private url: string = 'ws://localhost:3333') {
        this.connect();
    }

    connect(): void {
        try {
            this.ws = new WebSocket(this.url);

            this.ws.onopen = () => {
                console.log('[Angular X-Ray] Connected to performance monitor');
                this.reconnectAttempts = 0;
            };

            this.ws.onclose = () => {
                console.log('[Angular X-Ray] Disconnected from performance monitor');
                this.scheduleReconnect();
            };

            this.ws.onerror = (error) => {
                console.error('[Angular X-Ray] WebSocket error:', error);
            };
        } catch (error) {
            console.error('[Angular X-Ray] Failed to connect:', error);
            this.scheduleReconnect();
        }
    }

    private scheduleReconnect(): void {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            setTimeout(() => {
                console.log(`[Angular X-Ray] Reconnecting... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
                this.connect();
            }, this.reconnectDelay * this.reconnectAttempts);
        }
    }

    send(data: any): void {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
            this.ws.send(JSON.stringify(data));
        }
    }

    disconnect(): void {
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
    }
}

// Global WebSocket client instance
const wsClient = new XRayWebSocketClient();

/**
 * Performance monitoring decorator
 * Tracks method execution time and sends data to VS Code extension
 */
export function Performance(options: { threshold?: number } = {}) {
    return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
        const method = descriptor.value;
        const threshold = options.threshold || 0;

        descriptor.value = function (...args: any[]) {
            const startTime = performance.now();
            const className = target.constructor.name;

            try {
                const result = method.apply(this, args);

                // Handle both sync and async methods
                if (result && typeof result.then === 'function') {
                    // Async method
                    return result.then((asyncResult: any) => {
                        const executionTime = performance.now() - startTime;
                        if (executionTime >= threshold) {
                            sendPerformanceData(className, propertyName, executionTime, args, asyncResult);
                        }
                        return asyncResult;
                    }).catch((error: any) => {
                        const executionTime = performance.now() - startTime;
                        if (executionTime >= threshold) {
                            sendPerformanceData(className, propertyName, executionTime, args, null, error);
                        }
                        throw error;
                    });
                } else {
                    // Sync method
                    const executionTime = performance.now() - startTime;
                    if (executionTime >= threshold) {
                        sendPerformanceData(className, propertyName, executionTime, args, result);
                    }
                    return result;
                }
            } catch (error) {
                const executionTime = performance.now() - startTime;
                if (executionTime >= threshold) {
                    sendPerformanceData(className, propertyName, executionTime, args, null, error);
                }
                throw error;
            }
        };

        return descriptor;
    };
}

/**
 * Change detection tracking decorator
 * Monitors Angular change detection cycles
 */
export function TrackChangeDetection() {
    return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
        const method = descriptor.value;

        descriptor.value = function (...args: any[]) {
            const startTime = performance.now();
            const className = target.constructor.name;

            try {
                const result = method.apply(this, args);
                const executionTime = performance.now() - startTime;

                sendPerformanceData(className, propertyName, executionTime, args, result, null, 'change-detection');

                return result;
            } catch (error) {
                const executionTime = performance.now() - startTime;
                sendPerformanceData(className, propertyName, executionTime, args, null, error, 'change-detection');
                throw error;
            }
        };

        return descriptor;
    };
}

function sendPerformanceData(
    className: string,
    methodName: string,
    executionTime: number,
    args?: any[],
    result?: any,
    error?: any,
    type: string = 'performance'
): void {
    const data: PerformanceData & { type?: string; error?: any } = {
        className,
        methodName,
        executionTime,
        timestamp: Date.now(),
        args: args?.length ? args : undefined,
        result: result !== undefined ? result : undefined,
        type,
        error: error ? error.message || error : undefined
    };

    wsClient.send(data);
}

// Export WebSocket client for manual usage if needed
export { wsClient as XRayClient };
